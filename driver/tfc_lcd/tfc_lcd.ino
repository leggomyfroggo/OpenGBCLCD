// -------------------------------------------------- //
// This file is autogenerated by pioasm; do not edit! //
// -------------------------------------------------- //
 
#pragma once
 
#if !PICO_NO_HARDWARE
#include "hardware/pio.h"
#endif
 
#define LCD_WIDTH 160
#define LCD_HEIGHT 144
#define DCK_PIN 22
#define VSYNC_PIN 27
#define HSYNC_PIN 26
#define RED_PIN 0
#define HSYNC_START_IRQ 0
#define HSYNC_DONE_IRQ 1
 
// ------------- //
// vertical_loop //
// ------------- //
 
#define vertical_loop_wrap_target 0
#define vertical_loop_wrap 10
 
static const uint16_t vertical_loop_program_instructions[] = {
            //     .wrap_target
    0x80a0, //  0: pull   block                      
    0xa027, //  1: mov    x, osr                     
    0xa041, //  2: mov    y, x                       
    0x209b, //  3: wait   1 gpio, 27                 
    0x201b, //  4: wait   0 gpio, 27                 
    0x209a, //  5: wait   1 gpio, 26     
    0x201a, //  6: wait   0 gpio, 26                 
    0xc020, //  7: irq    wait 0                     
    0x20c1, //  8: wait   1 irq, 1                   
    0x0085, //  9: jmp    y--, 5                     
    0x0002, // 10: jmp    2                          
            //     .wrap
};
 
#if !PICO_NO_HARDWARE
static const struct pio_program vertical_loop_program = {
    .instructions = vertical_loop_program_instructions,
    .length = 11,
    .origin = -1,
};
 
static inline pio_sm_config vertical_loop_program_get_default_config(uint offset) {
    pio_sm_config c = pio_get_default_sm_config();
    sm_config_set_wrap(&c, offset + vertical_loop_wrap_target, offset + vertical_loop_wrap);
    return c;
}
 
static inline void vertical_loop_program_init(PIO pio, uint sm, uint offset, uint pin) {
    pio_sm_config c = vertical_loop_program_get_default_config(offset);
    // Configure the clocking pins for this PIO
    pio_gpio_init(pio, VSYNC_PIN);
    pio_gpio_init(pio, HSYNC_PIN);
    // Load our configuration
    pio_sm_init(pio, sm, offset, &c);
}
 
#endif
 
// --------------- //
// horizontal_loop //
// --------------- //
 
#define horizontal_loop_wrap_target 0
#define horizontal_loop_wrap 11
 
static const uint16_t horizontal_loop_program_instructions[] = {
            //     .wrap_target
    0x80a0, //  0: pull   block                      
    0xe041, //  1: set    y, 1                       
    0xa027, //  2: mov    x, osr                     
    0xa0e1, //  3: mov    osr, x                     
    0x20c0, //  4: wait   1 irq, 0                   
    0x2096, //  5: wait   1 gpio, 22                 
    0x2016, //  6: wait   0 gpio, 22                 
    0xa042, //  7: nop                               
    0x008c, //  8: jmp    y--, 12                    
    0x4010, //  9: in     pins, 16                   
    0xe041, // 10: set    y, 1                       
    0x000e, // 11: jmp    14                         
    0x4010, // 12: in     pins, 16                   
    0x4010, // 13: in     pins, 16                   
    0x0045, // 14: jmp    x--, 5                     
    0xc021, // 15: irq    wait 1                     
    0x0002, // 16: jmp    2                          
            //     .wrap
};
 
#if !PICO_NO_HARDWARE
static const struct pio_program horizontal_loop_program = {
    .instructions = horizontal_loop_program_instructions,
    .length = 17,
    .origin = -1,
};
 
static inline pio_sm_config horizontal_loop_program_get_default_config(uint offset) {
    pio_sm_config c = pio_get_default_sm_config();
    sm_config_set_wrap(&c, offset + horizontal_loop_wrap_target, offset + horizontal_loop_wrap);
    return c;
}
 
static inline void horizontal_loop_program_init(PIO pio, uint sm, uint offset, uint pin) {
    pio_sm_config c = horizontal_loop_program_get_default_config(offset);
    // Configure the data clocking pin for this PIO
    pio_gpio_init(pio, DCK_PIN);
    // Set the IN base pin to the provided `pin` parameter
    sm_config_set_in_pins(&c, pin);
    // Set the pin directions to input at the PIO
    pio_sm_set_consecutive_pindirs(pio, sm, pin, 15, false);
    // Connect these GPIOs to this PIO block
    for (int i = 0; i < 16; i++) {
        pio_gpio_init(pio, pin + i);
    }
    sm_config_set_in_shift(
        &c,
        false, // Shift-to-right = false (i.e. shift to left)
        true,  // Autopush enabled
        16      // Autopush threshold = 8
    );
    // Load our configuration
    pio_sm_init(pio, sm, offset, &c);
}
 
#endif
 
 
/*
  Ellipse drawing example
  
  This sketch does not use any fonts.
*/
 
#include <TB_TFT_eSPI.h> // Hardware-specific library
#include <SPI.h>
#include "pico/stdlib.h"
#include "hardware/gpio.h"
#include "hardware/dma.h"

// ==============================
// Display + Signal Config
// ==============================
TFT_eSPI tft = TFT_eSPI(); // Display library

// GPIO pin designators
const int pinSPS = 27;
const int pinSPL = 26;
const int pinDCK = 22;
const int pinTE = 23;
const int pinRed = 0;

// LCD signal properties
const uint16_t ROW_SIZE = 160;
const uint16_t COL_SIZE = 144;

// Screen buffer properties
const uint16_t BUFFER_WIDTH  = 240;
const uint16_t BUFFER_HEIGHT = 144;
const uint16_t BUFFER_SIZE   = BUFFER_WIDTH * BUFFER_HEIGHT;

// ==============================
// PIO State
// ==============================
PIO pio = pio0;
uint8_t v_sm = 0;
uint8_t h_sm = 0;

// ==============================
// DMA State (single channel, double buffering)
// ==============================
uint8_t dmaChannels[2];
uint16_t dmaBuffers[2][BUFFER_SIZE];
bool frameReady = false;
uint8_t readyFrameIndex = 1;

void __isr dmaHandler() {
  // read IRQ 0 status bits (which channels fired)
  uint32_t status = dma_hw->ints0;

  // Channel 0 finished?
  if (status & (1u << dmaChannels[0])) {
    // ack the IRQ for channel 0
    dma_hw->ints0 = 1u << dmaChannels[0];

    // mark buffer 0 as ready for display
    readyFrameIndex = 0;
    // re-arm write address and transfer count on channel 0
    dma_channel_set_write_addr(dmaChannels[0], dmaBuffers[0], false);
    dma_channel_set_trans_count(dmaChannels[0], BUFFER_SIZE, false);

    frameReady = true;
  }

  // Channel 1 finished?
  if (status & (1u << dmaChannels[1])) {
    dma_hw->ints0 = 1u << dmaChannels[1];

    readyFrameIndex = 1;
    dma_channel_set_write_addr(dmaChannels[1], dmaBuffers[1], false);
    dma_channel_set_trans_count(dmaChannels[1], BUFFER_SIZE, false);

    frameReady = true;
  }
}

void initializeDMA() {
  dmaChannels[0] = dma_claim_unused_channel(true);
  dmaChannels[1] = dma_claim_unused_channel(true);

  // Configure channel 0
  dma_channel_config c0 = dma_channel_get_default_config(dmaChannels[0]);
  channel_config_set_read_increment(&c0, false);
  channel_config_set_write_increment(&c0, true);
  channel_config_set_transfer_data_size(&c0, DMA_SIZE_16);
  channel_config_set_dreq(&c0, pio_get_dreq(pio, h_sm, false));
  channel_config_set_chain_to(&c0, dmaChannels[1]);
  dma_channel_configure(
    dmaChannels[0],
    &c0,
    dmaBuffers[0],
    &pio->rxf[h_sm],
    BUFFER_SIZE,
    false
  );

  // Configure channel 1
  dma_channel_config c1 = dma_channel_get_default_config(dmaChannels[1]);
  channel_config_set_read_increment(&c1, false);
  channel_config_set_write_increment(&c1, true);
  channel_config_set_transfer_data_size(&c1, DMA_SIZE_16);
  channel_config_set_dreq(&c1, pio_get_dreq(pio, h_sm, false));
  channel_config_set_chain_to(&c1, dmaChannels[0]);
  dma_channel_configure(
    dmaChannels[1],
    &c1,
    dmaBuffers[1],
    &pio->rxf[h_sm],
    BUFFER_SIZE,
    false
  );

  // Enable DMA IRQ
  dma_channel_set_irq0_enabled(dmaChannels[0], true);
  dma_channel_set_irq0_enabled(dmaChannels[1], true);
  irq_set_exclusive_handler(DMA_IRQ_0, dmaHandler);
  irq_set_enabled(DMA_IRQ_0, true);

  // Kickoff the first DMA channel
  dma_channel_start(dmaChannels[0]);
}

void setup() {
  // Setup TE pin
  pinMode(pinTE, OUTPUT);
  
  // PIO setup
  v_sm = pio_claim_unused_sm(pio, true);
  uint8_t v_offset = pio_add_program(pio, &vertical_loop_program);
  vertical_loop_program_init(pio, v_sm, v_offset, pinRed);
  pio_sm_put(pio, v_sm, COL_SIZE - 1);

  h_sm = pio_claim_unused_sm(pio, true);
  uint8_t h_offset = pio_add_program(pio, &horizontal_loop_program);
  horizontal_loop_program_init(pio, h_sm, h_offset, pinRed);
  pio_sm_put(pio, h_sm, ROW_SIZE - 1);

  // DMA setup
  initializeDMA();

  // TFT setup
  tft.init();
  tft.initDMA();
  tft.setSwapBytes(true);
  tft.fillScreen(TFT_BLACK);

  tft.writecommand(0x35);
  tft.writedata(0);

  // Start writing image data to the LCD
  tft.startWrite();

  // Kick off the PIO
  pio_sm_set_enabled(pio, v_sm, true);
  pio_sm_set_enabled(pio, h_sm, true);
}

// ==============================
// Main Loop
// ==============================
void loop() {
}

void loop1() {
  // Only act if a frame is ready AND TFT DMA is idle
  if (frameReady && !tft.dmaBusy()) {
    frameReady = false;

    // Push front buffer to display
    tft.setAddrWindow(0, 0, BUFFER_WIDTH, 216);
    bool yFlipper = readyFrameIndex == 0 ? true : false;
    uint16_t bi = 0;
    for (uint8_t y = 0; y < COL_SIZE; y++) {
      if (yFlipper) {
        tft.pushPixelsDMA(&dmaBuffers[readyFrameIndex][bi], BUFFER_WIDTH);
        tft.pushPixelsDMA(&dmaBuffers[readyFrameIndex][bi], BUFFER_WIDTH);
        bi += BUFFER_WIDTH;
      } else {
        tft.pushPixelsDMA(&dmaBuffers[readyFrameIndex][bi], BUFFER_WIDTH);
        bi += BUFFER_WIDTH;
      }
      yFlipper = !yFlipper;
    }
  }
}
